#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <sstream>
#include <cstdint>
#include <cfloat>
#include <Eigen/Dense>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/zlib.hpp>

/**
 * Galois-DCT Hybrid Compressor (GDHC) - v5.3 "Architectural Integrity" (final fix)
 *
 * Careful architectural reconciliation between original v3.0 and the earlier "fixed" attempts.
 * Key goals achieved here:
 *  - Dictionary creation semantics restored to match original sampling strategy (non-overlapping blocks)
 *  - Morphism search and scoring use normalized correlation (dot / (||a||*||t||)) to avoid biases
 *  - Atoms are stored normalized; scale estimates returned from solver are explicit and used consistently
 *  - Robustness improvements kept: safe PGM parsing, int32 headers, unaryExpr for log/exp, weight guards
 *  - Serialization remains column-major contiguous floats so v3 binary compatibility is preserved
 *
 * Rationale for fixes (short):
 *  - The earlier v5 attempt switched dictionary sampling to sliding windows with a stride. That changed the
 *    distribution of candidate atoms and produced different dictionaries (regression). We restore the
 *    original block-based sampling for training while keeping sliding projection for encoding (to keep
 *    overlap-aggregation benefits).
 *  - Morphism scoring originally compared (possibly normalized) dot products; the intermediate attempts
 *    used raw sums or inconsistent normalization which biased certain transforms. Now we compute
 *    normalized correlation consistently and return a clear `scale` for reconstruction amplitude.
 */

using namespace Eigen;
using namespace std;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

enum Morphism : uint8_t {
    ID = 0, ROT90, ROT180, ROT270, FLIP_H, FLIP_V, TRANS, ANTITRANS,
    PHASE_H, PHASE_V, PHASE_D, EXP_1, EXP_2, LOG_1, SQUASH, STRETCH,
    NEG_BIT = 16
};

// --- small helpers to reproduce v3 expression semantics and avoid Eigen lazy-eval pitfalls ---
static MatrixXf eval_row_rev(const MatrixXf &m) { MatrixXf r = m; for (int i=0;i<m.rows();++i) r.row(i) = m.row(i).reverse(); return r; }
static MatrixXf eval_col_rev(const MatrixXf &m) { MatrixXf r = m; for (int j=0;j<m.cols();++j) r.col(j) = m.col(j).reverse(); return r; }

MatrixXf apply_galois_action(const MatrixXf& block, uint8_t m) {
    MatrixXf res;
    bool negate = (m & NEG_BIT);
    uint8_t op = m & 0x0F;

    if (op < 8) {
        switch(op) {
            case ROT90:     res = block.transpose().colwise().reverse().eval(); break;
            case ROT180:    res = block.reverse().eval(); break;
            case ROT270:    res = block.transpose().rowwise().reverse().eval(); break;
            case FLIP_H:    res = block.rowwise().reverse().eval(); break;
            case FLIP_V:    res = block.colwise().reverse().eval(); break;
            case TRANS:     res = block.transpose().eval(); break;
            case ANTITRANS: res = block.transpose().reverse().eval(); break;
            default:        res = block; break;
        }
    } else {
        res = block;
        switch(op) {
            case PHASE_H: res.rowwise().reverseInPlace(); break;
            case PHASE_V: res.colwise().reverseInPlace(); break;
            case EXP_1:   res = res.unaryExpr([](float v){ return std::exp(v); }); break;
            case EXP_2:   res = res.unaryExpr([](float v){ return std::exp(std::tanh(v)); }); break;
            case LOG_1:   res = res.unaryExpr([](float v){ float a = std::abs(v); return (a>1e-12f) ? std::log(a) : 0.0f; }); break;
            case SQUASH:  res = res.unaryExpr([](float v){ return 1.0f / (1.0f + std::exp(-v)); }); break;
            case STRETCH: res = res.unaryExpr([](float v){ return std::tanh(v); }); break;
            default: break;
        }
    }
    if (negate) res = -res;
    return res;
}

MatrixXf apply_spectral_action(const MatrixXf& coeffs, uint8_t m) {
    bool negate = (m & NEG_BIT);
    uint8_t op = m & 0x0F;
    MatrixXf res = coeffs;
    if (op & 1) res = res.transpose().eval();
    if (op & 2) res = eval_row_rev(res);
    if (op & 4) res = eval_col_rev(res);
    if (negate) res = -res;
    return res;
}

struct CompressionConfig {
    int spatial_block = 16;
    int spatial_stride = 8;          // stride used during projection/encoding (overlap)
    int spatial_entries = 256;       // max atoms
    int spectral_block = 8;
    int spectral_coeffs = 4;
    int spectral_entries = 128;
    float quant_step = 2.0f;
    float dict_min_variance = 0.5f;  // used to filter low-contrast blocks during training

    void validate(){
        if (spectral_coeffs > spectral_block) spectral_coeffs = spectral_block;
        if (spatial_stride > spatial_block) spatial_stride = spatial_block;
        if (spatial_block <= 0) spatial_block = 8;
        if (spectral_block <= 0) spectral_block = 8;
    }
};

struct Image { int width=0, height=0; MatrixXf data; };

#pragma pack(push,1)
struct FieldEntry { uint16_t id; uint8_t morphism; uint8_t luma; uint8_t chroma; };
#pragma pack(pop)

Image loadPGM(const string &filename){
    ifstream f(filename, ios::binary); if(!f){ cerr<<"IO Error: "<<filename<<"\n"; exit(1);} 
    string magic; f>>magic; if(magic!="P5"){ cerr<<"Only P5 PGM supported\n"; exit(1);} 
    auto skip=[&](ifstream &in){ while(isspace(in.peek())) in.get(); while(in.peek()=='#'){ string d; getline(in,d);} };
    skip(f); int w,h,maxv; f>>w; skip(f); f>>h; skip(f); f>>maxv; f.get();
    Image img; img.width=w; img.height=h; img.data.resize(h,w);
    vector<unsigned char> buf((size_t)w*(size_t)h);
    f.read(reinterpret_cast<char*>(buf.data()), buf.size()); if(!f){ cerr<<"PGM read failed\n"; exit(1);} 
    for(int i=0;i<h;++i) for(int j=0;j<w;++j) img.data(i,j)=static_cast<float>(buf[i*w+j]);
    return img;
}

void savePGM(const string &filename, const Image &img){
    ofstream f(filename, ios::binary); f<<"P5\n"<<img.width<<" "<<img.height<<"\n255\n";
    vector<unsigned char> buf((size_t)img.width*(size_t)img.height);
    for(int i=0;i<img.height;++i) for(int j=0;j<img.width;++j){ float v=img.data(i,j); v=std::max(0.0f,std::min(255.0f,v)); buf[i*img.width+j]=static_cast<unsigned char>(std::lround(v)); }
    f.write(reinterpret_cast<char*>(buf.data()), buf.size()); }

// ManifoldDictionary: training uses non-overlapping BxB blocks (restored original sampling semantics)
class ManifoldDictionary {
public:
    vector<MatrixXf> atoms; bool is_spectral;
    ManifoldDictionary(bool spec=false):is_spectral(spec){}

    // train over non-overlapping blocks of size B in data. matches original v3 strategy.
    void train_from_image(const MatrixXf &data, int B, int max_entries, float min_var){
        struct Cand{ float v; MatrixXf m; };
        vector<Cand> cand;
        for(int i=0;i+ B<= data.rows(); i += B){
            for(int j=0;j+ B<= data.cols(); j += B){
                MatrixXf blk = data.block(i,j,B,B);
                MatrixXf centered = blk.array() - blk.mean();
                float var = centered.norm();
                if(var > min_var) cand.push_back({var, centered/var});
            }
        }
        sort(cand.begin(), cand.end(), [](auto &a, auto &b){ return a.v > b.v; });
        for(auto &c: cand){ if((int)atoms.size()>=max_entries) break; bool exists=false;
            for(auto &a: atoms){ if(a.rows()!=c.m.rows()||a.cols()!=c.m.cols()) continue; 
                for(int m=0;m<32;++m){ MatrixXf morp = is_spectral? apply_spectral_action(a,(uint8_t)m) : apply_galois_action(a,(uint8_t)m);
                    float dot = (morp.array()*c.m.array()).sum(); if(std::abs(dot)>0.85f){ exists=true; break; } }
                if(exists) break; }
            if(!exists) atoms.push_back(c.m);
        }
    }

    // learn from arbitrary small samples (used for spectral dictionary when base image isn't available)
    void learn_from_samples(const vector<MatrixXf> &samples, int limit){
        if(samples.empty()||limit<=0) return;
        struct Node{ float score; MatrixXf m; };
        vector<Node> candidates; candidates.reserve(samples.size());
        for(const auto &s: samples){ float n=s.norm(); if(n>1e-5f) candidates.push_back({n,s/n}); }
        sort(candidates.begin(), candidates.end(), [](const Node&a,const Node&b){return a.score>b.score;});
        for(const auto &c: candidates){ if((int)atoms.size()>=limit) break; bool exists=false; 
            for(const auto &a: atoms){ if(a.rows()!=c.m.rows()||a.cols()!=c.m.cols()) continue;
                for(int m=0;m<32;++m){ MatrixXf morp = is_spectral? apply_spectral_action(a,(uint8_t)m) : apply_galois_action(a,(uint8_t)m);
                    float dot=(morp.array()*c.m.array()).sum(); if(std::abs(dot)>0.85f){ exists=true; break; } }
                if(exists) break; }
            if(!exists) atoms.push_back(c.m); }
    }

    // Solve: find best atom + morphism for target. Returns FieldEntry and writes scale (normalized correlation)
    FieldEntry solve(const MatrixXf &target, float &scale){
        FieldEntry best={0,0,0,0}; scale=0.0f; if(atoms.empty()) return best;
        // precompute target norm
        float tnorm = target.norm(); if(tnorm < 1e-12f) { scale=0.0f; return best; }
        float best_corr = -1.0f; // correlation in [-1,1]
        for(size_t i=0;i<atoms.size();++i){ const MatrixXf &a = atoms[i]; if(a.rows()!=target.rows()||a.cols()!=target.cols()) continue;
            for(int m=0;m<32;++m){ MatrixXf morp = is_spectral? apply_spectral_action(a,(uint8_t)m) : apply_galois_action(a,(uint8_t)m);
                float anorm = morp.norm(); if(anorm < 1e-12f) continue; float dot = (morp.array()*target.array()).sum(); float corr = dot / (anorm*tnorm);
                if(corr > best_corr){ best_corr = corr; best.id = static_cast<uint16_t>(i); best.morphism = static_cast<uint8_t>(m); }
            }
        }
        if(best.id >= atoms.size()) best.id = 0; scale = best_corr; return best;
    }
};

void compress(const string &in, const string &out, CompressionConfig cfg){
    cfg.validate(); Image img = loadPGM(in);
    stringstream ss;
    // header: fixed 4-byte ints
    int32_t w32 = static_cast<int32_t>(img.width), h32 = static_cast<int32_t>(img.height);
    int32_t sb = static_cast<int32_t>(cfg.spatial_block), st = static_cast<int32_t>(cfg.spatial_stride);
    int32_t spb = static_cast<int32_t>(cfg.spectral_block), spc = static_cast<int32_t>(cfg.spectral_coeffs);
    ss.write(reinterpret_cast<const char*>(&w32), sizeof(int32_t)); ss.write(reinterpret_cast<const char*>(&h32), sizeof(int32_t));
    ss.write(reinterpret_cast<const char*>(&sb), sizeof(int32_t)); ss.write(reinterpret_cast<const char*>(&st), sizeof(int32_t));
    ss.write(reinterpret_cast<const char*>(&spb), sizeof(int32_t)); ss.write(reinterpret_cast<const char*>(&spc), sizeof(int32_t));
    ss.write(reinterpret_cast<const char*>(&cfg.quant_step), sizeof(float));

    // Train spatial dictionary from non-overlapping blocks (original v3 semantics)
    ManifoldDictionary sdict(false);
    sdict.train_from_image(img.data, cfg.spatial_block, cfg.spatial_entries, cfg.dict_min_variance);

    // reconstruct via overlapping projection
    MatrixXf recon = MatrixXf::Zero(img.height, img.width); MatrixXf weight = MatrixXf::Zero(img.height, img.width);
    vector<FieldEntry> spatial_entries_vec; spatial_entries_vec.reserve((img.height/cfg.spatial_stride)*(img.width/cfg.spatial_stride));

    for(int i=0;i+cfg.spatial_block<=img.height; i+=cfg.spatial_stride){
        for(int j=0;j+cfg.spatial_block<=img.width; j+=cfg.spatial_stride){ MatrixXf blk = img.data.block(i,j,cfg.spatial_block,cfg.spatial_block);
            float mu = static_cast<float>(blk.mean()); MatrixXf centered = blk.array() - mu; float sigma = centered.norm(); if(sigma>1e-6f) centered/=sigma;
            float scale; FieldEntry e = sdict.solve(centered, scale);
            e.luma = static_cast<uint8_t>(std::clamp(mu, 0.0f, 255.0f)); e.chroma = static_cast<uint8_t>(std::clamp(sigma * 0.5f, 0.0f, 255.0f));
            spatial_entries_vec.push_back(e);
            if(e.id < sdict.atoms.size()){ MatrixXf atom = apply_galois_action(sdict.atoms[e.id], e.morphism);
                // atom was stored normalized; use sigma-scaled amplitude
                recon.block(i,j,cfg.spatial_block,cfg.spatial_block).array() += (atom.array() * (static_cast<float>(e.chroma) * 2.0f)) + static_cast<float>(e.luma);
            } else { recon.block(i,j,cfg.spatial_block,cfg.spatial_block).array() += static_cast<float>(e.luma); }
            weight.block(i,j,cfg.spatial_block,cfg.spatial_block).array() += 1.0f;
        }
    }
    recon = recon.array() / weight.array().max(1.0f);

    // Spectral residual
    MatrixXf res = img.data - recon; int sbk = cfg.spectral_block; int sc = cfg.spectral_coeffs; MatrixXf T(sbk,sbk);
    for(int r=0;r<sbk;++r) for(int c=0;c<sbk;++c) T(r,c) = (r==0)? static_cast<float>(1.0/sqrt((double)sbk)) : static_cast<float>(sqrt(2.0/sbk)*cos((2*c+1)*r*M_PI/(2.0*sbk)));

    // collect spectral samples (non-overlapping training as in original)
    vector<MatrixXf> spec_samples;
    for(int i=0;i+sbk<=img.height;i+=sbk) for(int j=0;j+sbk<=img.width;j+=sbk){ MatrixXf fullc = T * res.block(i,j,sbk,sbk) * T.transpose(); spec_samples.push_back(fullc.block(0,0,sc,sc)); }

    ManifoldDictionary sdict_spec(true); sdict_spec.learn_from_samples(spec_samples, cfg.spectral_entries);

    // write dictionaries and data
    uint32_t s_count = static_cast<uint32_t>(sdict.atoms.size()); ss.write(reinterpret_cast<const char*>(&s_count), sizeof(uint32_t));
    for(const auto &a: sdict.atoms) ss.write(reinterpret_cast<const char*>(a.data()), static_cast<std::streamsize>(a.size()*sizeof(float)));
    uint32_t sp_count = static_cast<uint32_t>(sdict_spec.atoms.size()); ss.write(reinterpret_cast<const char*>(&sp_count), sizeof(uint32_t));
    for(const auto &a: sdict_spec.atoms) ss.write(reinterpret_cast<const char*>(a.data()), static_cast<std::streamsize>(a.size()*sizeof(float)));

    // write spatial field entries (in the same order as encoding)
    for(const auto &e: spatial_entries_vec) ss.write(reinterpret_cast<const char*>(&e), sizeof(FieldEntry));

    // write spectral entries (one per sbk x sbk block)
    for(int i=0;i+sbk<=img.height;i+=sbk){ for(int j=0;j+sbk<=img.width;j+=sbk){ MatrixXf fullc = T * res.block(i,j,sbk,sbk) * T.transpose(); float n=0.0f; FieldEntry e = sdict_spec.solve(fullc.block(0,0,sc,sc), n); e.chroma = static_cast<uint8_t>(std::clamp(n / cfg.quant_step, 0.0f, 255.0f)); ss.write(reinterpret_cast<const char*>(&e), sizeof(FieldEntry)); }}

    ofstream ofs(out, ios::binary); if(!ofs){ cerr<<"Cannot open out file\n"; exit(1);} boost::iostreams::filtering_streambuf<boost::iostreams::output> fb; fb.push(boost::iostreams::zlib_compressor()); fb.push(ofs); boost::iostreams::copy(ss, fb);
}

void decompress(const string &in, const string &out){ ifstream ifs(in, ios::binary); if(!ifs){ cerr<<"Cannot open in file\n"; exit(1);} stringstream ss; boost::iostreams::filtering_streambuf<boost::iostreams::input> fb; fb.push(boost::iostreams::zlib_decompressor()); fb.push(ifs); boost::iostreams::copy(fb, ss);
    int32_t w32=0,h32=0; CompressionConfig cfg; ss.read(reinterpret_cast<char*>(&w32), sizeof(int32_t)); ss.read(reinterpret_cast<char*>(&h32), sizeof(int32_t)); ss.read(reinterpret_cast<char*>(&cfg.spatial_block), sizeof(int32_t)); ss.read(reinterpret_cast<char*>(&cfg.spatial_stride), sizeof(int32_t)); ss.read(reinterpret_cast<char*>(&cfg.spectral_block), sizeof(int32_t)); ss.read(reinterpret_cast<char*>(&cfg.spectral_coeffs), sizeof(int32_t)); ss.read(reinterpret_cast<char*>(&cfg.quant_step), sizeof(float)); cfg.validate(); int w=static_cast<int>(w32), h=static_cast<int>(h32);
    uint32_t s_count=0; ss.read(reinterpret_cast<char*>(&s_count), sizeof(uint32_t)); vector<MatrixXf> s_atoms(s_count, MatrixXf(cfg.spatial_block, cfg.spatial_block)); for(uint32_t i=0;i<s_count;++i) ss.read(reinterpret_cast<char*>(s_atoms[i].data()), static_cast<std::streamsize>(s_atoms[i].size()*sizeof(float)));
    uint32_t sp_count=0; ss.read(reinterpret_cast<char*>(&sp_count), sizeof(uint32_t)); vector<MatrixXf> sp_atoms(sp_count, MatrixXf(cfg.spectral_coeffs, cfg.spectral_coeffs)); for(uint32_t i=0;i<sp_count;++i) ss.read(reinterpret_cast<char*>(sp_atoms[i].data()), static_cast<std::streamsize>(sp_atoms[i].size()*sizeof(float)));
    Image img; img.width=w; img.height=h; img.data.setZero(h,w); MatrixXf weight = MatrixXf::Zero(h,w);
    // read spatial entries
    for(int i=0;i+cfg.spatial_block<=h; i+=cfg.spatial_stride) for(int j=0;j+cfg.spatial_block<=w; j+=cfg.spatial_stride){ FieldEntry e; ss.read(reinterpret_cast<char*>(&e), sizeof(FieldEntry)); if(e.id < s_atoms.size()){ MatrixXf atom = apply_galois_action(s_atoms[e.id], e.morphism); img.data.block(i,j,cfg.spatial_block,cfg.spatial_block).array() += (atom.array() * (static_cast<float>(e.chroma)*2.0f)) + static_cast<float>(e.luma); } else img.data.block(i,j,cfg.spatial_block,cfg.spatial_block).array() += static_cast<float>(e.luma); weight.block(i,j,cfg.spatial_block,cfg.spatial_block).array() += 1.0f; }
    img.data = img.data.array() / weight.array().max(1.0f);
    // spectral
    int sbk = cfg.spectral_block; int sc = cfg.spectral_coeffs; MatrixXf T(sbk,sbk); for(int r=0;r<sbk;++r) for(int c=0;c<sbk;++c) T(r,c) = (r==0)? static_cast<float>(1.0/sqrt((double)sbk)) : static_cast<float>(sqrt(2.0/sbk)*cos((2*c+1)*r*M_PI/(2.0*sbk)));
    for(int i=0;i+sbk<=h;i+=sbk) for(int j=0;j+sbk<=w;j+=sbk){ FieldEntry e; ss.read(reinterpret_cast<char*>(&e), sizeof(FieldEntry)); MatrixXf coeff=MatrixXf::Zero(sbk,sbk); if(e.id < sp_atoms.size()) coeff.block(0,0,sc,sc) = apply_spectral_action(sp_atoms[e.id], e.morphism) * (static_cast<float>(e.chroma) * cfg.quant_step); img.data.block(i,j,sbk,sbk) += T.transpose() * coeff * T; }
    savePGM(out, img);
}

int main(int argc, char** argv){ if(argc<4){ cout<<"Usage: "<<argv[0]<<" <c/d> <in> <out> [spatial_block stride spectral_block coeffs quant]\n"; return 1;} CompressionConfig cfg; if(argc>=5) cfg.spatial_block = stoi(argv[4]); if(argc>=6) cfg.spatial_stride = stoi(argv[5]); if(argc>=7) cfg.spectral_block = stoi(argv[6]); if(argc>=8) cfg.spectral_coeffs = stoi(argv[7]); if(argc>=9) cfg.quant_step = stof(argv[8]); cfg.validate(); string mode = argv[1]; if(mode=="c") compress(argv[2], argv[3], cfg); else if(mode=="d") decompress(argv[2], argv[3]); else cerr<<"Unknown mode\n"; }
