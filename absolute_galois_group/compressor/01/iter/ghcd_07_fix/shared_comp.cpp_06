#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <sstream>
#include <Eigen/Dense>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/zlib.hpp>

/**
 * Galois-DCT Hybrid Compressor (GDHC) - v4.0 "Dual-Field Extension"
 * * Philosophy:
 * - L1 Ground Field: Spatial Dictionary Atoms (Invariants)
 * - L2 Spectral Field: DCT Coefficient Dictionary (Spectral Ideals)
 * - Unified Galois Search: Both Spatial and Spectral domains leverage Morphism Groups.
 */

using namespace Eigen;
using namespace std;

enum Morphism : uint8_t {
    ID = 0, ROT90, ROT180, ROT270, FLIP_H, FLIP_V, TRANS, ANTITRANS,
    INV_H, INV_V, INV_DIAG, GRAD_X, GRAD_Y, QUAD_1, QUAD_2, QUAD_3,
    NEG_OFFSET = 16 
};

// --- Math & Algebraic Helpers ---

MatrixXf apply_morphism(const MatrixXf& block, uint8_t m) {
    MatrixXf res;
    bool negate = (m >= NEG_OFFSET);
    uint8_t op = m % NEG_OFFSET;
    int N = block.rows();

    if (op < 8) {
        switch(op) {
            case ROT90:     res = block.transpose().colwise().reverse(); break;
            case ROT180:    res = block.reverse(); break;
            case ROT270:    res = block.transpose().rowwise().reverse(); break;
            case FLIP_H:    res = block.rowwise().reverse(); break;
            case FLIP_V:    res = block.colwise().reverse(); break;
            case TRANS:     res = block.transpose(); break;
            case ANTITRANS: res = block.transpose().reverse(); break;
            default:        res = block; break;
        }
    } else {
        res = block;
        switch(op) {
            case INV_H:    res.rowwise().reverseInPlace(); break;
            case INV_V:    res.colwise().reverseInPlace(); break;
            case GRAD_X:   { 
                VectorXf ramp = VectorXf::LinSpaced(N, 0.5f, 1.5f);
                res = res.array().rowwise() * ramp.transpose().array(); 
            } break;
            case GRAD_Y:   {
                VectorXf ramp = VectorXf::LinSpaced(N, 0.5f, 1.5f);
                res = res.array().colwise() * ramp.array();
            } break;
            case QUAD_1:   res = res.array().pow(1.2f); break; 
            case QUAD_2:   res = res.array().sqrt(); break;    
            default: break;
        }
    }
    return negate ? -res : res;
}

// Special Spectral Morphism for DCT blocks (Symmetries of the frequency grid)
MatrixXf apply_spectral_morphism(const MatrixXf& coeffs, uint8_t m) {
    bool negate = (m & 1);
    bool swap_axes = (m & 2);
    MatrixXf res = swap_axes ? coeffs.transpose() : coeffs;
    return negate ? -res : res;
}

struct CompressionConfig {
    int dict_block_size = 16;
    int dict_entries = 128;   
    int dct_block_size = 8;
    int spectral_entries = 64; // New: L2 Spectral Dictionary Size
    float dct_step = 4.0f;
    int dct_coeffs = 4; 

    void print() const {
        cout << "--- GDHC v4.0 Dual-Field Edition ---" << endl;
        cout << "L1 Ground Field: " << dict_block_size << "x" << dict_block_size << " [" << dict_entries << " atoms]" << endl;
        cout << "L2 Spectral Field: " << dct_block_size << "x" << dct_block_size << " [" << spectral_entries << " atoms]" << endl;
        cout << "DCT Precision: Step " << dct_step << " | Coeffs " << dct_coeffs << "x" << dct_coeffs << endl;
        cout << "------------------------------------" << endl;
    }
};

struct Image {
    int width, height;
    MatrixXf data;
};

#pragma pack(push, 1)
struct DictionaryEntry {
    uint16_t base_id;
    uint8_t morphism; 
};
#pragma pack(pop)

// --- PGM IO ---
Image loadPGM(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) exit(1);
    string magic; file >> magic;
    auto skip = [&](ifstream& f) { while (f >> ws && f.peek() == '#') { string d; getline(f, d); } };
    int w, h, maxVal;
    skip(file); file >> w; skip(file); file >> h; skip(file); file >> maxVal;
    file.ignore(1);
    Image img; img.width = w; img.height = h; img.data.resize(h, w);
    vector<unsigned char> buf(w * h);
    file.read((char*)buf.data(), buf.size());
    for (int i = 0; i < h; ++i)
        for (int j = 0; j < w; ++j)
            img.data(i, j) = (float)buf[i * w + j];
    return img;
}

void savePGM(const string& filename, const Image& img) {
    ofstream file(filename, ios::binary);
    file << "P5\n" << img.width << " " << img.height << "\n255\n";
    vector<unsigned char> buf(img.width * img.height);
    for (int i = 0; i < img.height; ++i)
        for (int j = 0; j < img.width; ++j)
            buf[i * img.width + j] = (unsigned char)std::max(0.f, std::min(255.f, img.data(i, j)));
    file.write((char*)buf.data(), buf.size());
}

class GaloisDictionary {
public:
    vector<MatrixXf> atoms;
    bool spectral;

    GaloisDictionary(bool is_spectral = false) : spectral(is_spectral) {}

    void train(const vector<MatrixXf>& samples, int max_entries) {
        struct Cand { float weight; MatrixXf mat; };
        vector<Cand> candidates;
        for (const auto& s : samples) {
            float n = s.norm();
            if (n > 0.1f) candidates.push_back({n, s / n});
        }
        sort(candidates.begin(), candidates.end(), [](const Cand& a, const Cand& b) { return a.weight > b.weight; });

        for (auto& c : candidates) {
            if (atoms.size() >= (size_t)max_entries) break;
            bool redundant = false;
            int m_count = spectral ? 4 : 32;
            for (const auto& a : atoms) {
                for (int m = 0; m < m_count; ++m) {
                    MatrixXf morphed = spectral ? apply_spectral_morphism(a, m) : apply_morphism(a, m);
                    if ((morphed.array() * c.mat.array()).sum() > 0.85f) { redundant = true; break; }
                }
                if (redundant) break;
            }
            if (!redundant) atoms.push_back(c.mat);
        }
    }

    DictionaryEntry find_best(const MatrixXf& target, float& out_norm) {
        float best_corr = -2.0f;
        DictionaryEntry best = {0, 0};
        int m_count = spectral ? 4 : 32;
        for (size_t i = 0; i < atoms.size(); ++i) {
            for (int m = 0; m < m_count; ++m) {
                MatrixXf morphed = spectral ? apply_spectral_morphism(atoms[i], m) : apply_morphism(atoms[i], m);
                float corr = (morphed.array() * target.array()).sum();
                if (corr > best_corr) {
                    best_corr = corr;
                    best = {(uint16_t)i, (uint8_t)m};
                }
            }
        }
        out_norm = best_corr;
        return best;
    }
};

void compress(const string& inputFile, const string& outputFile, const CompressionConfig& config) {
    Image img = loadPGM(inputFile);
    stringstream bitstream;

    // Header
    bitstream.write((char*)&img.width, 4); bitstream.write((char*)&img.height, 4);
    bitstream.write((char*)&config.dict_block_size, 4); bitstream.write((char*)&config.dict_entries, 4);
    bitstream.write((char*)&config.dct_block_size, 4); bitstream.write((char*)&config.spectral_entries, 4);
    bitstream.write((char*)&config.dct_step, 4); bitstream.write((char*)&config.dct_coeffs, 4);

    // L1 Training (Spatial Ground Field)
    vector<MatrixXf> spatial_samples;
    int B = config.dict_block_size;
    for (int i = 0; i + B <= img.height; i += B)
        for (int j = 0; j + B <= img.width; j += B)
            spatial_samples.push_back(img.data.block(i, j, B, B).array() - img.data.block(i, j, B, B).mean());
    
    GaloisDictionary spatial_dict(false);
    spatial_dict.train(spatial_samples, config.dict_entries);
    uint32_t s_ds = spatial_dict.atoms.size();
    bitstream.write((char*)&s_ds, 4);
    for (const auto& a : spatial_dict.atoms) bitstream.write((char*)a.data(), a.size() * sizeof(float));

    // L1 Encode
    MatrixXf recon = MatrixXf::Zero(img.height, img.width);
    for (int i = 0; i + B <= img.height; i += B) {
        for (int j = 0; j + B <= img.width; j += B) {
            MatrixXf blk = img.data.block(i, j, B, B);
            float m = blk.mean();
            MatrixXf centered = blk.array() - m;
            float norm = centered.norm();
            if (norm > 1e-6) centered /= norm;
            float match;
            DictionaryEntry e = spatial_dict.find_best(centered, match);
            uint8_t q_m = (uint8_t)std::max(0.f, std::min(255.f, m));
            uint8_t q_n = (uint8_t)std::max(0.f, std::min(255.f, norm * 0.5f));
            bitstream.write((char*)&e, sizeof(DictionaryEntry));
            bitstream.write((char*)&q_m, 1); bitstream.write((char*)&q_n, 1);
            recon.block(i, j, B, B) = (apply_morphism(spatial_dict.atoms[e.base_id], e.morphism) * (q_n * 2.0f)).array() + q_m;
        }
    }

    // L2 Spectral Dictionary Training
    MatrixXf residual = img.data - recon;
    int db = config.dct_block_size;
    MatrixXf T(db, db);
    float pi = acos(-1.0);
    for(int r=0; r<db; ++r)
        for(int c=0; c<db; ++c)
            T(r,c) = (r==0)? 1.0/sqrt(db) : sqrt(2.0/db)*cos((2*c+1)*r*pi/(2.0*db));

    vector<MatrixXf> spectral_samples;
    for (int i = 0; i + db <= img.height; i += db) {
        for (int j = 0; j + db <= img.width; j += db) {
            MatrixXf coeff = T * residual.block(i, j, db, db) * T.transpose();
            spectral_samples.push_back(coeff.block(0, 0, config.dct_coeffs, config.dct_coeffs));
        }
    }

    GaloisDictionary spectral_dict(true);
    spectral_dict.train(spectral_samples, config.spectral_entries);
    uint32_t spec_ds = spectral_dict.atoms.size();
    bitstream.write((char*)&spec_ds, 4);
    for (const auto& a : spectral_dict.atoms) bitstream.write((char*)a.data(), a.size() * sizeof(float));

    // L2 Encode (Spectral Extension)
    for (int i = 0; i + db <= img.height; i += db) {
        for (int j = 0; j + db <= img.width; j += db) {
            MatrixXf coeff = T * residual.block(i, j, db, db) * T.transpose();
            MatrixXf target = coeff.block(0, 0, config.dct_coeffs, config.dct_coeffs);
            float norm = target.norm();
            if (norm > 1e-6) target /= norm;
            float match;
            DictionaryEntry e = spectral_dict.find_best(target, match);
            uint8_t q_n = (uint8_t)std::max(0.f, std::min(255.f, norm / config.dct_step));
            bitstream.write((char*)&e, sizeof(DictionaryEntry));
            bitstream.write((char*)&q_n, 1);
        }
    }

    // Pipeline
    bitstream.seekg(0, ios::beg);
    ofstream outFile(outputFile, ios::binary);
    boost::iostreams::filtering_streambuf<boost::iostreams::output> out;
    out.push(boost::iostreams::zlib_compressor());
    out.push(outFile);
    boost::iostreams::copy(bitstream, out);
}

void decompress(const string& inputFile, const string& outputFile) {
    ifstream inFile(inputFile, ios::binary);
    stringstream bitstream;
    boost::iostreams::filtering_streambuf<boost::iostreams::input> in;
    in.push(boost::iostreams::zlib_decompressor());
    in.push(inFile);
    boost::iostreams::copy(in, bitstream);

    int w, h; CompressionConfig cfg;
    bitstream.read((char*)&w, 4); bitstream.read((char*)&h, 4);
    bitstream.read((char*)&cfg.dict_block_size, 4); bitstream.read((char*)&cfg.dict_entries, 4);
    bitstream.read((char*)&cfg.dct_block_size, 4); bitstream.read((char*)&cfg.spectral_entries, 4);
    bitstream.read((char*)&cfg.dct_step, 4); bitstream.read((char*)&cfg.dct_coeffs, 4);

    uint32_t s_ds; bitstream.read((char*)&s_ds, 4);
    vector<MatrixXf> s_atoms(s_ds, MatrixXf(cfg.dict_block_size, cfg.dict_block_size));
    for (uint32_t i = 0; i < s_ds; ++i) bitstream.read((char*)s_atoms[i].data(), s_atoms[i].size() * sizeof(float));

    Image img; img.width = w; img.height = h; img.data.setZero(h, w);
    int B = cfg.dict_block_size;
    for (int i = 0; i + B <= h; i += B) {
        for (int j = 0; j + B <= w; j += B) {
            DictionaryEntry e; bitstream.read((char*)&e, sizeof(DictionaryEntry));
            uint8_t q_m, q_n; bitstream.read((char*)&q_m, 1); bitstream.read((char*)&q_n, 1);
            img.data.block(i, j, B, B) = (apply_morphism(s_atoms[e.base_id], e.morphism) * (q_n * 2.0f)).array() + q_m;
        }
    }

    uint32_t spec_ds; bitstream.read((char*)&spec_ds, 4);
    vector<MatrixXf> spec_atoms(spec_ds, MatrixXf(cfg.dct_coeffs, cfg.dct_coeffs));
    for (uint32_t i = 0; i < spec_ds; ++i) bitstream.read((char*)spec_atoms[i].data(), spec_atoms[i].size() * sizeof(float));

    int db = cfg.dct_block_size;
    MatrixXf T(db, db); float pi = acos(-1.0);
    for(int r=0; r<db; ++r)
        for(int c=0; c<db; ++c)
            T(r,c) = (r==0)? 1.0/sqrt(db) : sqrt(2.0/db)*cos((2*c+1)*r*pi/(2.0*db));

    for (int i = 0; i + db <= h; i += db) {
        for (int j = 0; j + db <= w; j += db) {
            DictionaryEntry e; bitstream.read((char*)&e, sizeof(DictionaryEntry));
            uint8_t q_n; bitstream.read((char*)&q_n, 1);
            MatrixXf coeff = MatrixXf::Zero(db, db);
            coeff.block(0, 0, cfg.dct_coeffs, cfg.dct_coeffs) = apply_spectral_morphism(spec_atoms[e.base_id], e.morphism) * (q_n * cfg.dct_step);
            img.data.block(i, j, db, db) += T.transpose() * coeff * T;
        }
    }
    savePGM(outputFile, img);
}

int main(int argc, char* argv[]) {
    if (argc < 4) return 1;
    if (string(argv[1]) == "c") {
        CompressionConfig cfg;
        if (argc >= 9) cfg.dct_coeffs = stoi(argv[8]);
        compress(argv[2], argv[3], cfg);
    } else decompress(argv[2], argv[3]);
    return 0;
}
