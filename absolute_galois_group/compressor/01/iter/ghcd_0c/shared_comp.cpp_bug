#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <sstream>
#include <Eigen/Dense>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/zlib.hpp>

/**
 * Galois-DCT Hybrid Compressor (GDHC) - v5.0 "Manifold Extension"
 * * Philosophy:
 * - Image as Manifold: Sliding windows instead of fixed grids.
 * - Spectral Ideals: Dictionary-backed frequency reconstruction.
 * - Galois Group: 32 automorphisms including non-linear spectral twists.
 */

using namespace Eigen;
using namespace std;

// --- Galois Morphism Group (Extended) ---
enum Morphism : uint8_t {
    ID = 0, ROT90, ROT180, ROT270, FLIP_H, FLIP_V, TRANS, ANTITRANS,
    PHASE_H, PHASE_V, PHASE_D, EXP_1, EXP_2, LOG_1, SQUASH, STRETCH,
    NEG_BIT = 16 // Galois negation (field inversion)
};

MatrixXf apply_galois_action(const MatrixXf& block, uint8_t m) {
    MatrixXf res;
    bool negate = (m & NEG_BIT);
    uint8_t op = m & 0x0F;
    int N = block.rows();

    if (op < 8) { // Geometric Automorphisms
        switch(op) {
            case ROT90:     res = block.transpose().colwise().reverse(); break;
            case ROT180:    res = block.reverse(); break;
            case ROT270:    res = block.transpose().rowwise().reverse(); break;
            case FLIP_H:    res = block.rowwise().reverse(); break;
            case FLIP_V:    res = block.colwise().reverse(); break;
            case TRANS:     res = block.transpose(); break;
            case ANTITRANS: res = block.transpose().reverse(); break;
            default:        res = block; break;
        }
    } else { // Algebraic/Functional Extensions
        res = block;
        switch(op) {
            case PHASE_H: res.rowwise().reverseInPlace(); break;
            case PHASE_V: res.colwise().reverseInPlace(); break;
            case EXP_1:   res = res.array().exp(); break;
            case LOG_1:   res = res.array().abs().log().finite().select(res, 0); break;
            case SQUASH:  res = 1.0f / (1.0f + (-res.array()).exp()); break; // Sigmoid twist
            default: break;
        }
    }
    return negate ? -res : res;
}

// Spectral Domain Morphisms (Permutations of the frequency basis)
MatrixXf apply_spectral_action(const MatrixXf& coeffs, uint8_t m) {
    bool negate = (m & 1);
    bool swap = (m & 2);
    MatrixXf res = swap ? coeffs.transpose() : coeffs;
    if (m & 4) res = res.rowwise().reverse(); // Frequency inversion
    return negate ? -res : res;
}

struct CompressionConfig {
    int spatial_block = 16;
    int spatial_stride = 8;  // Sliding manifold stride
    int spatial_entries = 256;
    
    int spectral_block = 8;
    int spectral_entries = 128;
    float quant_step = 2.0f;

    void print() {
        cout << "--- GDHC v5.0 Manifold Edition ---" << endl;
        cout << "Spatial Manifold: " << spatial_block << "x" << spatial_block << " (Stride: " << spatial_stride << ")" << endl;
        cout << "Spectral Ideals: " << spectral_block << "x" << spectral_block << " [" << spectral_entries << " atoms]" << endl;
    }
};

struct Image {
    int width, height;
    MatrixXf data;
};

#pragma pack(push, 1)
struct FieldEntry {
    uint16_t id;
    uint8_t morphism;
    uint8_t luma;   // Scale/Offset (Cohomology)
    uint8_t chroma; 
};
#pragma pack(pop)

// --- IO Helpers ---
Image loadPGM(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) exit(1);
    string magic; file >> magic;
    int w, h, maxVal;
    file >> w >> h >> maxVal; file.ignore(1);
    Image img; img.width = w; img.height = h; img.data.resize(h, w);
    vector<unsigned char> buf(w * h);
    file.read((char*)buf.data(), buf.size());
    for (int i = 0; i < h; ++i)
        for (int j = 0; j < w; ++j)
            img.data(i, j) = (float)buf[i * w + j];
    return img;
}

void savePGM(const string& filename, const Image& img) {
    ofstream file(filename, ios::binary);
    file << "P5\n" << img.width << " " << img.height << "\n255\n";
    vector<unsigned char> buf(img.width * img.height);
    for (int i = 0; i < img.height; ++i)
        for (int j = 0; j < img.width; ++j)
            buf[i * img.width + j] = (unsigned char)std::max(0.f, std::min(255.f, img.data(i, j)));
    file.write((char*)buf.data(), buf.size());
}

// --- The Galois Manifold Dictionary ---
class ManifoldDictionary {
public:
    vector<MatrixXf> atoms;
    bool is_spectral;

    ManifoldDictionary(bool spec) : is_spectral(spec) {}

    void learn(const vector<MatrixXf>& samples, int limit) {
        struct Node { float score; MatrixXf m; };
        vector<Node> candidates;
        for (auto& s : samples) {
            float n = s.norm();
            if (n > 0.01f) candidates.push_back({n, s / n});
        }
        sort(candidates.begin(), candidates.end(), [](const Node& a, const Node& b){ return a.score > b.score; });

        for (auto& c : candidates) {
            if (atoms.size() >= (size_t)limit) break;
            bool exists = false;
            int m_range = is_spectral ? 8 : 32;
            for (auto& a : atoms) {
                for (int m = 0; m < m_range; ++m) {
                    MatrixXf morphed = is_spectral ? apply_spectral_action(a, m) : apply_galois_action(a, m);
                    if ((morphed.array() * c.m.array()).sum() > 0.92f) { exists = true; break; }
                }
                if (exists) break;
            }
            if (!exists) atoms.push_back(c.m);
        }
    }

    FieldEntry solve(const MatrixXf& target, float& scale) {
        float best_corr = -2.0f;
        FieldEntry best = {0, 0, 0, 0};
        int m_range = is_spectral ? 8 : 32;
        for (size_t i = 0; i < atoms.size(); ++i) {
            for (int m = 0; m < m_range; ++m) {
                MatrixXf morphed = is_spectral ? apply_spectral_action(atoms[i], m) : apply_galois_action(atoms[i], m);
                float corr = (morphed.array() * target.array()).sum();
                if (corr > best_corr) {
                    best_corr = corr;
                    best.id = (uint16_t)i;
                    best.morphism = (uint8_t)m;
                }
            }
        }
        scale = best_corr;
        return best;
    }
};

void compress(const string& in, const string& out, CompressionConfig cfg) {
    Image img = loadPGM(in);
    stringstream ss;
    
    // 1. Spatial Ground Field Learning (Sliding Manifold)
    vector<MatrixXf> spatial_samples;
    for (int i = 0; i + cfg.spatial_block <= img.height; i += cfg.spatial_stride)
        for (int j = 0; j + cfg.spatial_block <= img.width; j += cfg.spatial_stride)
            spatial_samples.push_back(img.data.block(i, j, cfg.spatial_block, cfg.spatial_block).array() - img.data.block(i, j, cfg.spatial_block, cfg.spatial_block).mean());
    
    ManifoldDictionary s_dict(false);
    s_dict.learn(spatial_samples, cfg.spatial_entries);

    // 2. Initial Manifold Reconstruction
    MatrixXf recon = MatrixXf::Zero(img.height, img.width);
    MatrixXf weight = MatrixXf::Zero(img.height, img.width);
    vector<FieldEntry> spatial_data;

    for (int i = 0; i + cfg.spatial_block <= img.height; i += cfg.spatial_stride) {
        for (int j = 0; j + cfg.spatial_block <= img.width; j += cfg.spatial_stride) {
            MatrixXf blk = img.data.block(i, j, cfg.spatial_block, cfg.spatial_block);
            float mu = blk.mean();
            MatrixXf centered = blk.array() - mu;
            float sigma = centered.norm();
            if (sigma > 1e-4) centered /= sigma;
            
            float scale;
            FieldEntry e = s_dict.solve(centered, scale);
            e.luma = (uint8_t)std::clamp(mu, 0.0f, 255.0f);
            e.chroma = (uint8_t)std::clamp(sigma * 0.5f, 0.0f, 255.0f);
            spatial_data.push_back(e);

            recon.block(i, j, cfg.spatial_block, cfg.spatial_block) += (apply_galois_action(s_dict.atoms[e.id], e.morphism) * (e.chroma * 2.0f)).array() + e.luma;
            weight.block(i, j, cfg.spatial_block, cfg.spatial_block).array() += 1.0f;
        }
    }
    recon = recon.array() / weight.array().max(1.0f);

    // 3. Spectral Ideal Learning
    MatrixXf res = img.data - recon;
    int sb = cfg.spectral_block;
    MatrixXf T(sb, sb);
    for(int r=0; r<sb; ++r)
        for(int c=0; c<sb; ++c)
            T(r,c) = (r==0)? 1.0/sqrt(sb) : sqrt(2.0/sb)*cos((2*c+1)*r*M_PI/(2.0*sb));

    vector<MatrixXf> spec_samples;
    for (int i = 0; i + sb <= img.height; i += sb)
        for (int j = 0; j + sb <= img.width; j += sb)
            spec_samples.push_back(T * res.block(i, j, sb, sb) * T.transpose());
    
    ManifoldDictionary spec_dict(true);
    spec_dict.learn(spec_samples, cfg.spectral_entries);

    // 4. Serialization (Zlib Pipeline)
    ss.write((char*)&img.width, 4); ss.write((char*)&img.height, 4);
    uint32_t s_size = s_dict.atoms.size(); ss.write((char*)&s_size, 4);
    for(auto& a : s_dict.atoms) ss.write((char*)a.data(), a.size()*4);
    
    uint32_t sp_size = spec_dict.atoms.size(); ss.write((char*)&sp_size, 4);
    for(auto& a : spec_dict.atoms) ss.write((char*)a.data(), a.size()*4);

    for(auto& e : spatial_data) ss.write((char*)&e, sizeof(FieldEntry));

    for (int i = 0; i + sb <= img.height; i += sb) {
        for (int j = 0; j + sb <= img.width; j += sb) {
            MatrixXf c = T * res.block(i, j, sb, sb) * T.transpose();
            float n;
            FieldEntry e = spec_dict.solve(c, n);
            e.chroma = (uint8_t)std::clamp(n / cfg.quant_step, 0.0f, 255.0f);
            ss.write((char*)&e, sizeof(FieldEntry));
        }
    }

    ofstream ofs(out, ios::binary);
    boost::iostreams::filtering_streambuf<boost::iostreams::output> out_z;
    out_z.push(boost::iostreams::zlib_compressor());
    out_z.push(ofs);
    boost::iostreams::copy(ss, out_z);
}

void decompress(const string& in, const string& out) {
    ifstream ifs(in, ios::binary);
    stringstream ss;
    boost::iostreams::filtering_streambuf<boost::iostreams::input> in_z;
    in_z.push(boost::iostreams::zlib_decompressor());
    in_z.push(ifs);
    boost::iostreams::copy(in_z, ss);

    int w, h; ss.read((char*)&w, 4); ss.read((char*)&h, 4);
    CompressionConfig cfg; // Default config for recovery logic
    
    uint32_t s_size; ss.read((char*)&s_size, 4);
    vector<MatrixXf> s_atoms(s_size, MatrixXf(cfg.spatial_block, cfg.spatial_block));
    for(uint32_t i=0; i<s_size; ++i) ss.read((char*)s_atoms[i].data(), s_atoms[i].size()*4);

    uint32_t sp_size; ss.read((char*)&sp_size, 4);
    vector<MatrixXf> sp_atoms(sp_size, MatrixXf(cfg.spectral_block, cfg.spectral_block));
    for(uint32_t i=0; i<sp_size; ++i) ss.read((char*)sp_atoms[i].data(), sp_atoms[i].size()*4);

    Image img; img.width = w; img.height = h; img.data.setZero(h, w);
    MatrixXf weight = MatrixXf::Zero(h, w);

    for (int i = 0; i + cfg.spatial_block <= h; i += cfg.spatial_stride) {
        for (int j = 0; j + cfg.spatial_block <= w; j += cfg.spatial_stride) {
            FieldEntry e; ss.read((char*)&e, sizeof(FieldEntry));
            img.data.block(i, j, cfg.spatial_block, cfg.spatial_block) += (apply_galois_action(s_atoms[e.id], e.morphism) * (e.chroma * 2.0f)).array() + e.luma;
            weight.block(i, j, cfg.spatial_block, cfg.spatial_block).array() += 1.0f;
        }
    }
    img.data = img.data.array() / weight.array().max(1.0f);

    int sb = cfg.spectral_block;
    MatrixXf T(sb, sb);
    for(int r=0; r<sb; ++r)
        for(int c=0; c<sb; ++c)
            T(r,c) = (r==0)? 1.0/sqrt(sb) : sqrt(2.0/db)*cos((2*c+1)*r*M_PI/(2.0*sb));

    for (int i = 0; i + sb <= h; i += sb) {
        for (int j = 0; j + sb <= w; j += sb) {
            FieldEntry e; ss.read((char*)&e, sizeof(FieldEntry));
            MatrixXf c = apply_spectral_action(sp_atoms[e.id], e.morphism) * (e.chroma * cfg.quant_step);
            img.data.block(i, j, sb, sb) += T.transpose() * c * T;
        }
    }
    savePGM(out, img);
}

int main(int argc, char** argv) {
    if (argc < 4) return 1;
    CompressionConfig cfg;
    if (string(argv[1]) == "c") compress(argv[2], argv[3], cfg);
    else decompress(argv[2], argv[3]);
    return 0;
}
