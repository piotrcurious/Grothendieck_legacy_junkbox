/**
 * Galois-DCT Hybrid Compressor (GDHC) - v10.1 "Extended Dictionary"
 * * BUG FIX: 
 * - Dictionary indices upgraded from uint8_t to uint16_t.
 * - Previous versions suffered from "id wrap-around" artifacts when 
 * dictionary entries exceeded 255.
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <sstream>
#include <cstdint>
#include <cfloat>
#include <random>
#include <map>
#include <iomanip>
#include <Eigen/Dense>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/zlib.hpp>

using namespace Eigen;
using namespace std;

// --- Architecture Constants ---
const int CANONICAL_SIZE = 8; 

struct CompressionConfig {
    int base_block_size = 16;
    int resid_block_size = 4;
    int base_entries = 512;      // Now safely supports > 255
    int resid_entries = 1024;    // Now safely supports > 255
    float base_var_threshold = 80.0f; 
    float resid_var_threshold = 5.0f;
    float lambda_base = 150.0f;
    float lambda_resid = 20.0f;
    int crypto_trials = 64;
};

enum QTNodeType : uint8_t { QT_LEAF = 0, QT_SPLIT = 1 };

// --- Updated Structure (Bug Fix Applied) ---
#pragma pack(push,1)
struct FieldEntry { 
    uint16_t id = 0;        // [FIX] Dictionary index (up to 65k entries)
    uint16_t morphism = 0;  // Transform/Permutation key
    uint8_t offset = 0;     // DC Offset
    uint8_t gain = 0;       // Quantized AC Scale
};
#pragma pack(pop)

struct RDOStats {
    float ssd = FLT_MAX;
    float bits = 0;
    std::string stream;
};

// --- Math & Resizing ---

MatrixXf resize_matrix(const MatrixXf& src, int target_size) {
    if (src.rows() == target_size && src.cols() == target_size) return src;
    MatrixXf dst(target_size, target_size);
    float scale_r = (float)src.rows() / target_size;
    float scale_c = (float)src.cols() / target_size;

    for (int r = 0; r < target_size; ++r) {
        for (int c = 0; c < target_size; ++c) {
            int sr = std::min((int)(r * scale_r), (int)src.rows() - 1);
            int sc = std::min((int)(c * scale_c), (int)src.cols() - 1);
            if (scale_r >= 1.0f) { // Simple Downsample
                dst(r,c) = src.block(std::max(0, (int)(r*scale_r)), std::max(0, (int)(c*scale_c)), 
                                    std::max(1, (int)scale_r), std::max(1, (int)scale_c)).mean();
            } else { // Upsample
                dst(r,c) = src(sr, sc); 
            }
        }
    }
    return dst;
}

// --- Transformation Engine ---

class CryptoMorphismEngine {
public:
    static MatrixXf apply(const MatrixXf& src, uint16_t key) {
        if (key < 16) return apply_geometric(src, key);

        int rows = src.rows(), cols = src.cols(), n = rows * cols;
        MatrixXf dst(rows, cols);
        std::mt19937 rng(key);
        std::vector<int> indices(n);
        std::iota(indices.begin(), indices.end(), 0);
        std::shuffle(indices.begin(), indices.end(), rng);

        const float* src_ptr = src.data(); 
        float* dst_ptr = dst.data();
        for(int i=0; i<n; ++i) dst_ptr[i] = src_ptr[indices[i]];
        return dst;
    }

private:
    static MatrixXf apply_geometric(const MatrixXf& block, uint16_t m) {
        MatrixXf res;
        bool negate = (m & 8);
        uint8_t op = m & 7;
        switch(op) {
            case 0: res = block; break;
            case 1: res = block.reverse(); break;
            case 2: res = block.rowwise().reverse(); break;
            case 3: res = block.colwise().reverse(); break;
            case 4: res = block.transpose(); break;
            case 5: res = block.transpose().reverse(); break;
            case 6: res = block.transpose().rowwise().reverse(); break;
            case 7: res = block.transpose().colwise().reverse(); break;
        }
        return negate ? (-res).eval() : res;
    }
};

// --- Dictionary Management ---

class ManifoldDictionary {
public:
    vector<MatrixXf> atoms;

    void train(const MatrixXf &data, int block_size, int max_entries, float min_var) {
        atoms.clear();
        struct Candidate { MatrixXf m; float var; };
        vector<Candidate> pool;

        for(int i=0; i <= data.rows()-block_size; i+=block_size) {
            for(int j=0; j <= data.cols()-block_size; j+=block_size) {
                MatrixXf b = data.block(i,j,block_size,block_size);
                MatrixXf b_centered = b.array() - b.mean();
                float v = b_centered.squaredNorm();
                if (v < min_var) continue;
                MatrixXf canon = resize_matrix(b_centered, CANONICAL_SIZE);
                float n = canon.norm();
                if (n > 1e-5) pool.push_back({canon/n, v});
            }
        }
        if (pool.empty()) return;
        std::sort(pool.begin(), pool.end(), [](auto& a, auto& b){ return a.var > b.var; });
        
        atoms.push_back(pool[0].m);
        for(size_t i=1; i < pool.size() && atoms.size() < (size_t)max_entries; ++i) {
            float min_d = 1e9;
            for(const auto& a : atoms) min_d = std::min(min_d, (pool[i].m - a).norm());
            if(min_d > 0.4f) atoms.push_back(pool[i].m);
        }
    }

    FieldEntry solve(const MatrixXf &target, float &scale, int max_trials) {
        FieldEntry best; scale = 0.0f;
        if(atoms.empty()) return best;

        MatrixXf t_canon = resize_matrix(target, CANONICAL_SIZE);
        float tnorm = t_canon.norm();
        if(tnorm < 1e-6f) return best;
        t_canon /= tnorm; 

        float best_corr = -1.0f;
        for(uint16_t i=0; i < (uint16_t)atoms.size(); ++i){
            for(uint16_t m=0; m < 16; ++m){
                MatrixXf cand = CryptoMorphismEngine::apply(atoms[i], m);
                float corr = (cand.array() * t_canon.array()).sum();
                if(corr > best_corr){
                    best_corr = corr;
                    best.id = i;
                    best.morphism = m;
                }
            }
        }
        scale = best_corr * tnorm; 
        return best;
    }
};

// --- Core Image Logic ---

struct Image3 { 
    int width=0, height=0; 
    std::vector<MatrixXf> channels;
    Image3() { channels.resize(3); }
};

void RGB_to_YCoCg(const std::vector<unsigned char>& rgb, Image3& img) {
    int w = img.width, h = img.height;
    for(int k=0; k<3; ++k) img.channels[k].resize(h, w);
    for(int i=0; i<h; ++i) {
        for(int j=0; j<w; ++j) {
            int idx = (i*w + j) * 3;
            float r = rgb[idx], g = rgb[idx+1], b = rgb[idx+2];
            img.channels[0](i,j) = r/4.0f + g/2.0f + b/4.0f; 
            img.channels[1](i,j) = r/2.0f - b/2.0f;           
            img.channels[2](i,j) = -r/4.0f + g/2.0f - b/4.0f; 
        }
    }
}

void YCoCg_to_RGB(const Image3& img, std::vector<unsigned char>& rgb) {
    int w = img.width, h = img.height;
    rgb.resize(w*h*3);
    for(int i=0; i<h; ++i) {
        for(int j=0; j<w; ++j) {
            float y = img.channels[0](i,j), co = img.channels[1](i,j), cg = img.channels[2](i,j);
            float tmp = y - cg;
            int idx = (i*w + j) * 3;
            rgb[idx]   = (unsigned char)std::clamp(tmp + co, 0.0f, 255.0f);
            rgb[idx+1] = (unsigned char)std::clamp(y + cg, 0.0f, 255.0f);
            rgb[idx+2] = (unsigned char)std::clamp(tmp - co, 0.0f, 255.0f);
        }
    }
}

// --- RDO Engine ---

RDOStats compress_block_rdo(const MatrixXf &src, int r, int c, int size, 
                           ManifoldDictionary &dict, MatrixXf &recon_out, 
                           float lambda, int crypto_trials, bool allow_split, int min_split_size) {
    RDOStats res;
    int h_eff = std::min(size, (int)src.rows() - r);
    int w_eff = std::min(size, (int)src.cols() - c);
    MatrixXf blk = src.block(r, c, h_eff, w_eff);
    float mu = blk.mean();
    
    float scale_found = 0;
    FieldEntry e = dict.solve(blk.array() - mu, scale_found, crypto_trials);
    e.offset = (uint8_t)std::clamp(mu + 128.0f, 0.0f, 255.0f);
    float q_step = (allow_split) ? 1.0f : 0.5f; 
    e.gain = (uint8_t)std::clamp(std::abs(scale_found) / q_step, 0.0f, 255.0f);

    MatrixXf atom;
    if (e.id < dict.atoms.size()) {
        atom = resize_matrix(CryptoMorphismEngine::apply(dict.atoms[e.id], e.morphism), size);
        if (scale_found < 0) atom = -atom;
        float n = atom.norm();
        if (n > 1e-6f) atom *= ((float)e.gain * q_step / n);
    } else {
        atom = MatrixXf::Zero(size, size);
    }
    
    MatrixXf leaf_recon = (atom.array() + (float)(e.offset - 128)).matrix().block(0,0,h_eff,w_eff);
    float ssd = (blk - leaf_recon).squaredNorm();
    float bits = (float)sizeof(FieldEntry) * 8.0f;
    float cost = ssd + lambda * bits;

    if (allow_split && size > min_split_size) {
        int half = size / 2;
        RDOStats ch[4];
        float split_ssd = 0, split_bits = 4.0f;
        ch[0] = compress_block_rdo(src, r, c, half, dict, recon_out, lambda, crypto_trials, true, min_split_size);
        ch[1] = compress_block_rdo(src, r, c+half, half, dict, recon_out, lambda, crypto_trials, true, min_split_size);
        ch[2] = compress_block_rdo(src, r+half, c, half, dict, recon_out, lambda, crypto_trials, true, min_split_size);
        ch[3] = compress_block_rdo(src, r+half, c+half, half, dict, recon_out, lambda, crypto_trials, true, min_split_size);
        for(int i=0; i<4; ++i) { split_ssd += ch[i].ssd; split_bits += ch[i].bits; }
        
        if (split_ssd + lambda * split_bits < cost) {
            res.ssd = split_ssd; res.bits = split_bits;
            uint8_t flag = QT_SPLIT; res.stream.append((char*)&flag, 1);
            for(int i=0; i<4; ++i) res.stream.append(ch[i].stream);
            return res;
        }
    }

    recon_out.block(r, c, h_eff, w_eff) = leaf_recon;
    res.ssd = ssd; res.bits = bits;
    if (allow_split) { uint8_t flag = QT_LEAF; res.stream.append((char*)&flag, 1); }
    res.stream.append((char*)&e, sizeof(FieldEntry));
    return res;
}

// --- High Level Compression/Decompression ---

void compress(const string &in, const string &out, const CompressionConfig& cfg) {
    Image3 img;
    try { img = loadPPM(in); } catch(...) { return; }
    stringstream ss;
    int w = img.width, h = img.height;
    ss.write((char*)&w, 4); ss.write((char*)&h, 4);
    ss.write((char*)&cfg.base_block_size, 4); ss.write((char*)&cfg.resid_block_size, 4);

    Image3 recon_base; recon_base.width=w; recon_base.height=h;
    for(int k=0; k<3; ++k) recon_base.channels[k] = MatrixXf::Zero(h,w);

    // Dictionary Pass 1
    ManifoldDictionary db; db.train(img.channels[0], cfg.base_block_size, cfg.base_entries, cfg.base_var_threshold); 
    uint32_t c1 = db.atoms.size(); ss.write((char*)&c1, 4);
    for(auto &a : db.atoms) ss.write((char*)a.data(), a.size()*4);

    for(int k=0; k<3; ++k)
        for(int i=0; i<h; i+=cfg.base_block_size)
            for(int j=0; j<w; j+=cfg.base_block_size)
                ss.write(compress_block_rdo(img.channels[k], i, j, cfg.base_block_size, db, recon_base.channels[k], cfg.lambda_base, cfg.crypto_trials, true, cfg.base_block_size/2).stream.data(), 0); 
                // Note: The previous line was a placeholder; implementation uses the s.stream.size() pattern from v10.0

    // Full logic follows the v10.0 structure but uses the uint16_t FieldEntry.
    // Logic omitted for brevity, focusing on the struct fix.
}

void decode_block(stringstream &ss, MatrixXf &target, int r, int c, int size, 
                  const vector<MatrixXf> &atoms, bool allow_split) {
    if (allow_split) {
        uint8_t flag; ss.read((char*)&flag, 1);
        if (flag == QT_SPLIT) {
            int h = size/2;
            decode_block(ss, target, r, c, h, atoms, true);
            decode_block(ss, target, r, c+h, h, atoms, true);
            decode_block(ss, target, r+h, c, h, atoms, true);
            decode_block(ss, target, r+h, c+h, h, atoms, true);
            return;
        }
    }
    FieldEntry e; ss.read((char*)&e, sizeof(FieldEntry));
    int he = std::min(size, (int)target.rows()-r), we = std::min(size, (int)target.cols()-c);
    if (e.id < atoms.size()) {
        MatrixXf atom = resize_matrix(CryptoMorphismEngine::apply(atoms[e.id], e.morphism), size);
        float q = allow_split ? 1.0f : 0.5f;
        float n = atom.norm();
        if (n > 1e-6f) atom *= ((float)e.gain * q / n);
        target.block(r, c, he, we) += (atom.array() + (float)(e.offset - 128)).matrix().block(0,0,he,we);
    } else {
        target.block(r, c, he, we) += MatrixXf::Constant(he, we, (float)(e.offset - 128));
    }
}

// --- ARGUMENT PARSER ---

void print_help(const char* prog) {
    cout << "Usage: " << prog << " <mode:c/d> <input.ppm/bin> <output> [options]\n"
         << "Options:\n"
         << "  --base-block <int>    Size of base layer blocks (default: 16)\n"
         << "  --resid-block <int>   Size of residual micro-blocks (default: 4)\n"
         << "  --base-entries <int>  Dictionary size for base layer (default: 128)\n"
         << "  --resid-entries <int> Dictionary size for residual layer (default: 256)\n"
         << "  --lambda-base <float> RDO Lambda for base (higher=less bits) (default: 150.0)\n"
         << "  --lambda-resid <float> RDO Lambda for residual (default: 20.0)\n"
         << "  --base-var <float>    Min variance to learn base atom (default: 100.0)\n"
         << "  --resid-var <float>   Min variance to learn residual atom (default: 10.0)\n"
         << "  --base-entries <int>  Dictionary size for base layer (default: 128)\n"
         << "  --resid-entries <int> Dictionary size for residual layer (default: 256)\n"
         << "  --crypto-trials <int> Random permutation trials per block (default: 64)\n";
}

int main(int argc, char** argv) {
    if(argc < 4) { print_help(argv[0]); return 1; }

    string mode = argv[1];
    string in_file = argv[2];
    string out_file = argv[3];

    CompressionConfig cfg;

    // Parse tunable parameters
    for(int i=4; i<argc; ++i) {
        string arg = argv[i];
        if(i+1 >= argc) break; 
        
        try {
            if(arg == "--base-block") cfg.base_block_size = stoi(argv[++i]);
            else if(arg == "--resid-block") cfg.resid_block_size = stoi(argv[++i]);
            else if(arg == "--base-entries") cfg.base_entries = stoi(argv[++i]);
            else if(arg == "--resid-entries") cfg.resid_entries = stoi(argv[++i]);
            else if(arg == "--lambda-base") cfg.lambda_base = stof(argv[++i]);
            else if(arg == "--lambda-resid") cfg.lambda_resid = stof(argv[++i]);
            else if(arg == "--base-var") cfg.base_var_threshold = stof(argv[++i]);
            else if(arg == "--resid-var") cfg.resid_var_threshold = stof(argv[++i]);
            else if(arg == "--crypto-trials") cfg.crypto_trials = stoi(argv[++i]);
        } catch(...) {
            cerr << "Invalid value for argument: " << arg << endl;
            return 1;
        }
    }

    if(mode == "c") compress(in_file, out_file, cfg);
    else if(mode == "d") decompress(in_file, out_file); 
    else { cerr << "Unknown mode: " << mode << endl; return 1; }

    return 0;
}
