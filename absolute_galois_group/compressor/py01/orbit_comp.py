"""
Prototype: Algebraic Basis Reduction + TRUE Finite-Field Galois Conjugacy

This version upgrades the previous prototype by replacing the heuristic
"orbit" canonicalization with *true Galois conjugacy* over a finite field.

We work over GF(2^8) using the AES irreducible polynomial:
    x^8 + x^4 + x^3 + x + 1  (0x11B)

Key mathematical structure
--------------------------
- Each image block is reduced via SVD (real field R) to a low-rank algebraic
  representation.
- The reduced coefficients (singular vectors + values) are quantized into
  bytes and interpreted as elements of GF(2^8).
- The absolute Galois group of GF(2^8) over GF(2) is cyclic, generated by
  the Frobenius automorphism:
        φ(a) = a^2
- True Galois conjugacy classes are generated by repeated Frobenius action.
- Each block representation is canonicalized by selecting the lexicographically
  minimal conjugate in its Galois orbit.

Compression stores:
- One canonical representative per orbit (dictionary)
- For each block: (dictionary index, Frobenius power k)

This is now *genuinely Galois-theoretic*: equivalence is defined by field
automorphisms, not ad-hoc symmetry.

Limitations
-----------
- Uses GF(2^8); extension to GF(p^n) is straightforward.
- Quantization is simplistic; optimize for rate–distortion.
- Still a research prototype, not production codec.
"""

import argparse
import numpy as np
from numpy.linalg import svd
import math

# ----------------------------- Parameters -----------------------------
BLOCK = 8
RANK = 2
QUANT_SCALE = 127.0
SV_QUANT_SCALE = 100.0
# ---------------------------------------------------------------------

# ======================= Finite Field GF(2^8) =========================
AES_POLY = 0x11B


def gf_mul(a, b):
    res = 0
    for _ in range(8):
        if b & 1:
            res ^= a
        hi = a & 0x80
        a = (a << 1) & 0xFF
        if hi:
            a ^= AES_POLY & 0xFF
        b >>= 1
    return res


def gf_square(a):
    return gf_mul(a, a)


def frobenius(a, k):
    # φ^k(a) = a^(2^k)
    for _ in range(k):
        a = gf_square(a)
    return a


def frobenius_vector(v, k):
    return np.array([frobenius(int(x) & 0xFF, k) for x in v], dtype=np.uint8)

# ============================ PGM I/O =================================

def load_pgm(filename):
    with open(filename, 'rb') as f:
        if f.readline().strip() != b'P5':
            raise ValueError('Only P5 supported')
        line = f.readline()
        while line.startswith(b'#'):
            line = f.readline()
        w, h = map(int, line.split())
        f.readline()
        data = np.frombuffer(f.read(w * h), dtype=np.uint8).astype(np.float32)
        return data.reshape(h, w)


def save_pgm(filename, img):
    h, w = img.shape
    img8 = np.clip(np.round(img), 0, 255).astype(np.uint8)
    with open(filename, 'wb') as f:
        f.write(b'P5\n')
        f.write(f'{w} {h}\n255\n'.encode())
        f.write(img8.tobytes())

# ======================== Algebraic Reduction =========================

def svd_reduce(block):
    U, s, Vt = svd(block, full_matrices=False)
    return U[:, :RANK], s[:RANK], Vt[:RANK, :]


def quantize(U, s, Vt):
    Uq = np.clip(np.round(U * QUANT_SCALE), -128, 127).astype(np.int8)
    Vq = np.clip(np.round(Vt * QUANT_SCALE), -128, 127).astype(np.int8)
    Sq = np.clip(np.round(s * SV_QUANT_SCALE), 0, 255).astype(np.uint8)
    return Uq, Sq, Vq


def pack_repr(Uq, Sq, Vq):
    return np.concatenate([
        (Uq.astype(np.int16) & 0xFF).ravel(),
        Sq.astype(np.int16).ravel(),
        (Vq.astype(np.int16) & 0xFF).ravel()
    ]).astype(np.uint8)

# ======================= True Galois Canonical ========================

def galois_canonical(byte_vec):
    """
    Compute the canonical representative of the Galois orbit
    under Frobenius automorphism in GF(2^8).
    Returns (canonical_vector, k) where k is the Frobenius power.
    """
    best = None
    best_k = 0
    cur = byte_vec.copy()
    for k in range(8):  # orbit size divides 8
        if best is None or tuple(cur) < tuple(best):
            best = cur.copy()
            best_k = k
        cur = frobenius_vector(cur, 1)
    return best, best_k

# ======================= Compression / Decompression ==================

def compress(img):
    h, w = img.shape
    blocks = []
    for i in range(0, h - BLOCK + 1, BLOCK):
        for j in range(0, w - BLOCK + 1, BLOCK):
            blocks.append(img[i:i+BLOCK, j:j+BLOCK])

    dictionary = {}
    dict_list = []
    encoded = []

    for b in blocks:
        U, s, Vt = svd_reduce(b)
        Uq, Sq, Vq = quantize(U, s, Vt)
        packed = pack_repr(Uq, Sq, Vq)
        canon, k = galois_canonical(packed)
        key = bytes(canon)
        if key not in dictionary:
            dictionary[key] = len(dict_list)
            dict_list.append(canon)
        encoded.append((dictionary[key], k))

    return {
        'shape': img.shape,
        'dict': np.stack(dict_list),
        'codes': np.array(encoded, dtype=np.uint8)
    }


def decompress(data):
    h, w = data['shape']
    out = np.zeros((h, w), dtype=np.float32)
    idx = 0
    for i in range(0, h - BLOCK + 1, BLOCK):
        for j in range(0, w - BLOCK + 1, BLOCK):
            d_idx, k = data['codes'][idx]
            canon = data['dict'][d_idx]
            vec = frobenius_vector(canon, (8 - k) % 8)
            # unpack
            p = 0
            Uq = (vec[p:p+BLOCK*RANK].reshape(BLOCK, RANK).astype(np.int8)); p += BLOCK*RANK
            Sq = vec[p:p+RANK].astype(np.float32) / SV_QUANT_SCALE; p += RANK
            Vq = (vec[p:p+RANK*BLOCK].reshape(RANK, BLOCK).astype(np.int8))
            U = Uq.astype(np.float32) / QUANT_SCALE
            Vt = Vq.astype(np.float32) / QUANT_SCALE
            block = (U * Sq[np.newaxis, :]) @ Vt
            out[i:i+BLOCK, j:j+BLOCK] = block
            idx += 1
    return out

# =============================== CLI ==================================

def psnr(a, b):
    mse = np.mean((a - b) ** 2)
    if mse == 0:
        return float('inf')
    return 20 * math.log10(255.0 / math.sqrt(mse))


if __name__ == '__main__':
    ap = argparse.ArgumentParser()
    ap.add_argument('--compress', action='store_true')
    ap.add_argument('--decompress', action='store_true')
    ap.add_argument('input')
    ap.add_argument('output')
    args = ap.parse_args()

    if args.compress:
        img = load_pgm(args.input)
        data = compress(img)
        np.savez_compressed(args.output, **data)
    elif args.decompress:
        z = np.load(args.input)
        data = {k: z[k] for k in z}
        img = decompress(data)
        save_pgm(args.output, img)
